"""Agente Orquestrador Central para coordenar sistema multiagente.

Este agente √© respons√°vel por:
- Receber consultas dos usu√°rios
- Determinar qual(is) agente(s) especializado(s) utilizar
- Coordenar m√∫ltiplos agentes quando necess√°rio
- Combinar respostas de diferentes agentes
- Manter contexto da conversa√ß√£o
- Fornecer interface √∫nica para o sistema completo
"""
from __future__ import annotations
import sys
import os
from pathlib import Path

# Adiciona o diret√≥rio raiz do projeto ao PYTHONPATH
root_dir = Path(__file__).parent.parent.parent
sys.path.insert(0, str(root_dir))

import re
from typing import Any, Dict, List, Optional, Union, Tuple
from dataclasses import dataclass
from enum import Enum

from src.agent.base_agent import BaseAgent, AgentError
from src.agent.csv_analysis_agent import CSVAnalysisAgent
from src.data.data_processor import DataProcessor

# Import condicional do RAGAgent (pode falhar se Supabase n√£o configurado)
try:
    from src.agent.rag_agent import RAGAgent
    RAG_AGENT_AVAILABLE = True
except ImportError as e:
    RAG_AGENT_AVAILABLE = False
    RAGAgent = None
    print(f"‚ö†Ô∏è RAGAgent n√£o dispon√≠vel: {str(e)[:100]}...")
except RuntimeError as e:
    RAG_AGENT_AVAILABLE = False  
    RAGAgent = None
    print(f"‚ö†Ô∏è RAGAgent n√£o dispon√≠vel: {str(e)[:100]}...")


class QueryType(Enum):
    """Tipos de consultas que o orquestrador pode processar."""
    CSV_ANALYSIS = "csv_analysis"      # An√°lise de dados CSV
    RAG_SEARCH = "rag_search"          # Busca sem√¢ntica/contextual
    DATA_LOADING = "data_loading"      # Carregamento de dados
    HYBRID = "hybrid"                  # M√∫ltiplos agentes necess√°rios
    GENERAL = "general"                # Consulta geral/conversacional
    UNKNOWN = "unknown"                # Tipo n√£o identificado


@dataclass
class AgentTask:
    """Representa uma tarefa para um agente espec√≠fico."""
    agent_name: str
    query: str
    context: Optional[Dict[str, Any]] = None
    priority: int = 1  # 1=alta, 2=m√©dia, 3=baixa


@dataclass
class OrchestratorResponse:
    """Resposta consolidada do orquestrador."""
    content: str
    query_type: QueryType
    agents_used: List[str]
    metadata: Dict[str, Any]
    success: bool = True
    error: Optional[str] = None


class OrchestratorAgent(BaseAgent):
    """Agente central que coordena todos os agentes especializados."""
    
    def __init__(self, 
                 enable_csv_agent: bool = True,
                 enable_rag_agent: bool = True,
                 enable_data_processor: bool = True):
        """Inicializa o orquestrador com agentes especializados.
        
        Args:
            enable_csv_agent: Habilitar agente de an√°lise CSV
            enable_rag_agent: Habilitar agente RAG
            enable_data_processor: Habilitar processador de dados
        """
        super().__init__(
            name="orchestrator",
            description="Coordenador central do sistema multiagente de IA para an√°lise de dados"
        )
        
        # Inicializar agentes especializados
        self.agents = {}
        self.conversation_history = []
        self.current_data_context = {}
        
        # Inicializar agentes com tratamento de erro gracioso
        initialization_errors = []
        
        # CSV Agent (sempre dispon√≠vel - sem depend√™ncias externas)
        if enable_csv_agent:
            try:
                self.agents["csv"] = CSVAnalysisAgent()
                self.logger.info("‚úÖ Agente CSV inicializado")
            except Exception as e:
                error_msg = f"CSV Agent: {str(e)}"
                initialization_errors.append(error_msg)
                self.logger.warning(f"‚ö†Ô∏è {error_msg}")
        
        # RAG Agent (requer Supabase configurado)
        if enable_rag_agent and RAG_AGENT_AVAILABLE:
            try:
                self.agents["rag"] = RAGAgent()
                self.logger.info("‚úÖ Agente RAG inicializado")
            except Exception as e:
                error_msg = f"RAG Agent: {str(e)}"
                initialization_errors.append(error_msg)
                self.logger.warning(f"‚ö†Ô∏è {error_msg}")
        elif enable_rag_agent and not RAG_AGENT_AVAILABLE:
            error_msg = "RAG Agent: Depend√™ncias n√£o dispon√≠veis (Supabase n√£o configurado)"
            initialization_errors.append(error_msg)
            self.logger.warning(f"‚ö†Ô∏è {error_msg}")
        
        # Data Processor (sempre dispon√≠vel - sem depend√™ncias externas)  
        if enable_data_processor:
            try:
                self.data_processor = DataProcessor()
                self.logger.info("‚úÖ Data Processor inicializado")
            except Exception as e:
                error_msg = f"Data Processor: {str(e)}"
                initialization_errors.append(error_msg)
                self.logger.warning(f"‚ö†Ô∏è {error_msg}")
                self.data_processor = None
        else:
            self.data_processor = None
        
        # Log do resultado da inicializa√ß√£o
        if self.agents or self.data_processor:
            self.logger.info(f"üöÄ Orquestrador inicializado com {len(self.agents)} agentes")
            if initialization_errors:
                self.logger.warning(f"‚ö†Ô∏è {len(initialization_errors)} componentes falharam na inicializa√ß√£o")
        else:
            self.logger.error("‚ùå Nenhum agente foi inicializado com sucesso")
            if initialization_errors:
                raise AgentError(
                    self.name, 
                    f"Falha na inicializa√ß√£o de todos os componentes: {'; '.join(initialization_errors)}"
                )
    
    def process(self, query: str, context: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """Processa consulta determinando agente(s) apropriado(s).
        
        Args:
            query: Consulta do usu√°rio
            context: Contexto adicional (file_path, dados, configura√ß√µes)
        
        Returns:
            Resposta consolidada do sistema
        """
        self.logger.info(f"üéØ Processando consulta: '{query[:50]}...'")
        
        try:
            # 1. Adicionar √† hist√≥ria da conversa
            self.conversation_history.append({
                "type": "user_query",
                "query": query,
                "timestamp": self._get_timestamp(),
                "context": context
            })
            
            # 2. Analisar tipo da consulta
            query_type = self._classify_query(query, context)
            self.logger.info(f"üìù Tipo de consulta identificado: {query_type.value}")
            
            # 3. Processar baseado no tipo
            if query_type == QueryType.CSV_ANALYSIS:
                result = self._handle_csv_analysis(query, context)
            elif query_type == QueryType.RAG_SEARCH:
                result = self._handle_rag_search(query, context)
            elif query_type == QueryType.DATA_LOADING:
                result = self._handle_data_loading(query, context)
            elif query_type == QueryType.HYBRID:
                result = self._handle_hybrid_query(query, context)
            elif query_type == QueryType.GENERAL:
                result = self._handle_general_query(query, context)
            else:
                result = self._handle_unknown_query(query, context)
            
            # 4. Adicionar √† hist√≥ria
            self.conversation_history.append({
                "type": "system_response",
                "response": result,
                "timestamp": self._get_timestamp()
            })
            
            return result
            
        except Exception as e:
            self.logger.error(f"Erro no processamento: {str(e)}")
            return self._build_response(
                f"‚ùå Erro no processamento da consulta: {str(e)}",
                metadata={
                    "error": True,
                    "query_type": "error",
                    "agents_used": []
                }
            )
    
    def _classify_query(self, query: str, context: Optional[Dict[str, Any]]) -> QueryType:
        """Classifica o tipo de consulta para roteamento adequado.
        
        Args:
            query: Consulta do usu√°rio
            context: Contexto adicional
        
        Returns:
            Tipo da consulta identificado
        """
        query_lower = query.lower()
        
        # Palavras-chave para cada tipo de consulta
        csv_keywords = [
            'csv', 'tabela', 'dados', 'an√°lise', 'estat√≠stica', 'correla√ß√£o',
            'gr√°fico', 'plot', 'visualiza√ß√£o', 'resumo', 'describe', 'dataset',
            'colunas', 'linhas', 'm√©dia', 'mediana', 'fraude', 'outlier'
        ]
        
        rag_keywords = [
            'buscar', 'procurar', 'encontrar', 'pesquisar', 'consultar',
            'conhecimento', 'base', 'documento', 'texto', 'similar',
            'contexto', 'embedding', 'sem√¢ntica', 'retrieval'
        ]
        
        data_keywords = [
            'carregar', 'upload', 'importar', 'abrir', 'arquivo',
            'dados sint√©ticos', 'gerar dados', 'criar dados', 'load'
        ]
        
        general_keywords = [
            'ol√°', 'oi', 'ajuda', 'como', 'o que', 'qual', 'quando',
            'onde', 'por que', 'explicar', 'definir', 'status', 'sistema'
        ]
        
        # Verificar contexto de arquivo
        has_file_context = context and 'file_path' in context
        
        # Classificar baseado em palavras-chave e contexto
        csv_score = sum(1 for kw in csv_keywords if kw in query_lower)
        rag_score = sum(1 for kw in rag_keywords if kw in query_lower)
        data_score = sum(1 for kw in data_keywords if kw in query_lower)
        general_score = sum(1 for kw in general_keywords if kw in query_lower)
        
        # Adicionar peso do contexto
        if has_file_context:
            if any(ext in str(context.get('file_path', '')).lower() for ext in ['.csv', '.xlsx', '.json']):
                csv_score += 2
        
        # Verificar se precisa de m√∫ltiplos agentes
        scores = [csv_score, rag_score, data_score]
        high_scores = [s for s in scores if s >= 2]
        
        if len(high_scores) >= 2:
            return QueryType.HYBRID
        
        # Determinar tipo baseado na maior pontua√ß√£o
        max_score = max(csv_score, rag_score, data_score, general_score)
        
        if max_score == 0:
            return QueryType.UNKNOWN
        elif max_score == csv_score:
            return QueryType.CSV_ANALYSIS
        elif max_score == rag_score:
            return QueryType.RAG_SEARCH
        elif max_score == data_score:
            return QueryType.DATA_LOADING
        else:
            return QueryType.GENERAL
    
    def _handle_csv_analysis(self, query: str, context: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Delega an√°lise CSV para o agente especializado."""
        if "csv" not in self.agents:
            return self._build_response(
                "‚ùå Agente de an√°lise CSV n√£o est√° dispon√≠vel",
                metadata={"error": True, "agents_used": []}
            )
        
        self.logger.info("üìä Delegando para agente CSV")
        
        # Preparar contexto para o agente CSV
        csv_context = context or {}
        
        # Se h√° dados carregados no orquestrador, passar para o agente
        if self.current_data_context:
            csv_context.update(self.current_data_context)
        
        result = self.agents["csv"].process(query, csv_context)
        
        # Atualizar contexto se dados foram carregados
        if result.get("metadata") and not result["metadata"].get("error"):
            self.current_data_context.update(result["metadata"])
        
        return self._enhance_response(result, ["csv"])
    
    def _handle_rag_search(self, query: str, context: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Delega busca sem√¢ntica para o agente RAG."""
        if "rag" not in self.agents:
            return self._build_response(
                "‚ùå Agente RAG n√£o est√° dispon√≠vel",
                metadata={"error": True, "agents_used": []}
            )
        
        self.logger.info("üîç Delegando para agente RAG")
        
        result = self.agents["rag"].process(query, context)
        return self._enhance_response(result, ["rag"])
    
    def _handle_data_loading(self, query: str, context: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Processa carregamento de dados."""
        if not self.data_processor:
            return self._build_response(
                "‚ùå Sistema de carregamento de dados n√£o est√° dispon√≠vel",
                metadata={"error": True, "agents_used": []}
            )
        
        self.logger.info("üìÅ Processando carregamento de dados")
        
        try:
            # Verificar se foi fornecido um arquivo
            if context and 'file_path' in context:
                file_path = context['file_path']
                
                # Carregar dados usando DataProcessor
                result = self.data_processor.load_from_file(file_path)
                
                if not result.get('error'):
                    # Armazenar contexto dos dados carregados
                    self.current_data_context = {
                        'file_path': file_path,
                        'data_info': result.get('data_info', {}),
                        'quality_report': result.get('quality_report', {})
                    }
                    
                    # Criar resposta informativa
                    data_info = result.get('data_info', {})
                    quality_report = result.get('quality_report', {})
                    
                    response = f"""‚úÖ **Dados Carregados com Sucesso**

üìÑ **Arquivo:** {file_path}
üìä **Dimens√µes:** {data_info.get('rows', 0):,} linhas √ó {data_info.get('columns', 0)} colunas
‚≠ê **Qualidade:** {quality_report.get('overall_score', 0):.1f}/100

**Pr√≥ximos passos dispon√≠veis:**
‚Ä¢ An√°lise explorat√≥ria: "fa√ßa um resumo dos dados"
‚Ä¢ Correla√ß√µes: "mostre as correla√ß√µes"  
‚Ä¢ Visualiza√ß√µes: "crie gr√°ficos dos dados"
‚Ä¢ Busca sem√¢ntica: "busque informa√ß√µes sobre fraude"
"""
                    
                    return self._build_response(
                        response,
                        metadata={
                            "agents_used": ["data_processor"],
                            "data_loaded": True,
                            "file_path": file_path,
                            "data_info": data_info,
                            "quality_report": quality_report
                        }
                    )
                else:
                    return self._build_response(
                        f"‚ùå Erro ao carregar dados: {result.get('error', 'Erro desconhecido')}",
                        metadata={"error": True, "agents_used": ["data_processor"]}
                    )
            
            else:
                # Instru√ß√µes de como carregar dados
                response = """üìÅ **Como Carregar Dados**

Para carregar dados, use:
```
context = {"file_path": "caminho/para/seu/arquivo.csv"}
```

**Formatos suportados:**
‚Ä¢ CSV (.csv)
‚Ä¢ Excel (.xlsx) - *em desenvolvimento*
‚Ä¢ JSON (.json) - *em desenvolvimento*

**Dados sint√©ticos dispon√≠veis:**
‚Ä¢ Detec√ß√£o de fraude
‚Ä¢ Dados de vendas  
‚Ä¢ Dados de clientes
‚Ä¢ Dados gen√©ricos
"""
                
                return self._build_response(
                    response,
                    metadata={"agents_used": [], "instructions": True}
                )
        
        except Exception as e:
            self.logger.error(f"Erro no carregamento: {str(e)}")
            return self._build_response(
                f"‚ùå Erro no carregamento de dados: {str(e)}",
                metadata={"error": True, "agents_used": ["data_processor"]}
            )
    
    def _handle_hybrid_query(self, query: str, context: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Processa consultas que requerem m√∫ltiplos agentes."""
        self.logger.info("üîÑ Processando consulta h√≠brida (m√∫ltiplos agentes)")
        
        results = []
        agents_used = []
        
        # Determinar quais agentes s√£o necess√°rios
        query_lower = query.lower()
        
        # CSV + RAG (ex: "analise os dados e busque informa√ß√µes similares")
        if any(kw in query_lower for kw in ['dados', 'csv', 'an√°lise']) and \
           any(kw in query_lower for kw in ['buscar', 'similar', 'contexto']):
            
            # Primeiro: an√°lise CSV se h√° dados
            if "csv" in self.agents and self.current_data_context:
                csv_result = self.agents["csv"].process(query, context)
                results.append(("csv", csv_result))
                agents_used.append("csv")
            
            # Segundo: busca RAG
            if "rag" in self.agents:
                rag_result = self.agents["rag"].process(query, context)
                results.append(("rag", rag_result))
                agents_used.append("rag")
        
        # Se nenhum resultado, usar abordagem padr√£o
        if not results:
            return self._handle_csv_analysis(query, context)
        
        # Combinar resultados
        combined_response = self._combine_agent_responses(results)
        
        return self._build_response(
            combined_response,
            metadata={"agents_used": agents_used, "hybrid_query": True}
        )
    
    def _handle_general_query(self, query: str, context: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Processa consultas gerais/conversacionais."""
        self.logger.info("üí¨ Processando consulta geral")
        
        query_lower = query.lower()
        
        # Sauda√ß√µes
        if any(greeting in query_lower for greeting in ['ol√°', 'oi', 'ola']):
            response = """üëã **Ol√°! Sou o Orquestrador do Sistema EDA AI Minds**

Sou o coordenador central que pode te ajudar com:

üîç **An√°lise de Dados CSV**
‚Ä¢ Carregamento e valida√ß√£o de arquivos
‚Ä¢ Estat√≠sticas e correla√ß√µes  
‚Ä¢ Visualiza√ß√µes e insights

üß† **Busca Sem√¢ntica (RAG)**
‚Ä¢ Consultas contextualizadas
‚Ä¢ Base de conhecimento vetorial
‚Ä¢ Respostas inteligentes

**Como posso te ajudar hoje?**
"""
            return self._build_response(response, metadata={"agents_used": [], "greeting": True})
        
        # Status do sistema
        elif any(status in query_lower for status in ['status', 'sistema', 'agentes']):
            return self._get_system_status()
        
        # Ajuda
        elif 'ajuda' in query_lower or 'help' in query_lower:
            return self._get_help_response()
        
        # Usar LLM para resposta geral
        else:
            llm_response = self._call_llm(
                f"Voc√™ √© um assistente de IA especializado em an√°lise de dados. "
                f"Responda de forma √∫til e direta √† seguinte pergunta: {query}",
                context,
                temperature=0.3
            )
            
            if llm_response.get("error"):
                response = "Desculpe, n√£o consegui processar sua consulta. Tente ser mais espec√≠fico ou pergunte sobre an√°lise de dados CSV ou busca sem√¢ntica."
            else:
                response = llm_response.get("choices", [{}])[0].get("message", {}).get("content", "Sem resposta dispon√≠vel.")
            
            return self._build_response(response, metadata={"agents_used": ["llm"], "general_query": True})
    
    def _handle_unknown_query(self, query: str, context: Optional[Dict[str, Any]]) -> Dict[str, Any]:
        """Processa consultas de tipo desconhecido."""
        self.logger.warning(f"ü§î Consulta de tipo desconhecido: {query[:50]}...")
        
        response = f"""ü§î **N√£o consegui identificar o tipo da sua consulta**

**Sua consulta:** "{query}"

**Posso te ajudar com:**
‚Ä¢ üìä **An√°lise de dados:** "analise o arquivo dados.csv"
‚Ä¢ üîç **Busca sem√¢ntica:** "busque informa√ß√µes sobre fraude"
‚Ä¢ üìÅ **Carregar dados:** use context={{"file_path": "arquivo.csv"}}

**Reformule sua pergunta ou seja mais espec√≠fico sobre o que precisa.**
"""
        
        return self._build_response(response, metadata={"agents_used": [], "unknown_query": True})
    
    def _combine_agent_responses(self, results: List[Tuple[str, Dict[str, Any]]]) -> str:
        """Combina respostas de m√∫ltiplos agentes em uma resposta coesa."""
        if not results:
            return "Nenhum resultado dispon√≠vel."
        
        combined = "üîÑ **Resposta Consolidada de M√∫ltiplos Agentes**\n\n"
        
        for agent_name, result in results:
            agent_display = {
                "csv": "üìä **An√°lise CSV**",
                "rag": "üîç **Busca Sem√¢ntica**"
            }.get(agent_name, f"ü§ñ **{agent_name.upper()}**")
            
            combined += f"{agent_display}\n"
            combined += f"{result.get('content', 'Sem conte√∫do')}\n\n"
            combined += "‚îÄ" * 50 + "\n\n"
        
        return combined.rstrip("‚îÄ\n ")
    
    def _enhance_response(self, agent_result: Dict[str, Any], agents_used: List[str]) -> Dict[str, Any]:
        """Melhora resposta do agente com informa√ß√µes do orquestrador."""
        if not agent_result:
            return self._build_response("Erro: resposta vazia do agente", metadata={"error": True})
        
        # Preservar conte√∫do original
        enhanced = agent_result.copy()
        
        # Adicionar informa√ß√µes do orquestrador
        if "metadata" not in enhanced:
            enhanced["metadata"] = {}
        
        enhanced["metadata"]["orchestrator"] = {
            "agents_used": agents_used,
            "conversation_length": len(self.conversation_history),
            "has_data_context": bool(self.current_data_context)
        }
        
        return enhanced
    
    def _get_system_status(self) -> Dict[str, Any]:
        """Retorna status completo do sistema."""
        status_info = {
            "agents": {},
            "data_context": bool(self.current_data_context),
            "conversation_history": len(self.conversation_history)
        }
        
        # Status dos agentes
        for name, agent in self.agents.items():
            status_info["agents"][name] = {
                "available": True,
                "name": agent.name,
                "description": agent.description
            }
        
        # Status do data processor
        if self.data_processor:
            status_info["data_processor"] = {"available": True}
        
        # Informa√ß√µes sobre dados carregados
        data_info = ""
        if self.current_data_context:
            file_path = self.current_data_context.get('file_path', 'N/A')
            data_info = f"\nüìÅ **Dados Carregados:** {file_path}"
        
        response = f"""‚ö° **Status do Sistema EDA AI Minds**

ü§ñ **Agentes Dispon√≠veis:** {len(self.agents)}
{chr(10).join(f'‚Ä¢ {name.upper()}: {agent.description}' for name, agent in self.agents.items())}

üíæ **Data Processor:** {'‚úÖ Ativo' if self.data_processor else '‚ùå Inativo'}
üí¨ **Hist√≥rico:** {len(self.conversation_history)} intera√ß√µes{data_info}

üöÄ **Sistema Operacional e Pronto!**
"""
        
        return self._build_response(response, metadata=status_info)
    
    def _get_help_response(self) -> Dict[str, Any]:
        """Retorna informa√ß√µes de ajuda completas."""
        help_text = """üìö **Guia de Uso do Sistema EDA AI Minds**

## üîç **Tipos de Consulta**

### üìä **An√°lise de Dados CSV**
```python
# Carregar arquivo
context = {"file_path": "dados.csv"}
query = "carregue os dados"

# An√°lises
"fa√ßa um resumo dos dados"
"mostre as correla√ß√µes"
"analise fraudes"
"crie visualiza√ß√µes"
```

### üß† **Busca Sem√¢ntica (RAG)**
```python
"busque informa√ß√µes sobre detec√ß√£o de fraude"
"encontre dados similares a transa√ß√µes suspeitas"
"qual o contexto sobre an√°lise de risco?"
```

### üìÅ **Carregamento de Dados**
```python
"carregar arquivo CSV"
"importar dados"
"gerar dados sint√©ticos"
```

## üí° **Dicas**
‚Ä¢ Seja espec√≠fico nas consultas
‚Ä¢ Use contexto para fornecer arquivos
‚Ä¢ Combine diferentes tipos de an√°lise
‚Ä¢ Pergunte sobre status do sistema

**Exemplo Completo:**
```python
# 1. Carregar dados
context = {"file_path": "fraude.csv"}
"carregue e analise os dados"

# 2. An√°lise espec√≠fica  
"mostre correla√ß√µes entre valor e fraude"

# 3. Busca contextual
"busque padr√µes similares na base de conhecimento"
```
"""
        
        return self._build_response(help_text, metadata={"help": True, "agents_used": []})
    
    def get_conversation_history(self) -> List[Dict[str, Any]]:
        """Retorna hist√≥rico completo da conversa."""
        return self.conversation_history.copy()
    
    def clear_conversation_history(self) -> Dict[str, Any]:
        """Limpa hist√≥rico da conversa."""
        count = len(self.conversation_history)
        self.conversation_history.clear()
        self.logger.info(f"Hist√≥rico limpo: {count} intera√ß√µes removidas")
        
        return self._build_response(
            f"‚úÖ Hist√≥rico limpo: {count} intera√ß√µes removidas",
            metadata={"cleared_count": count}
        )
    
    def clear_data_context(self) -> Dict[str, Any]:
        """Limpa contexto de dados carregados."""
        if self.current_data_context:
            file_path = self.current_data_context.get('file_path', 'N/A')
            self.current_data_context.clear()
            self.logger.info(f"Contexto de dados limpo: {file_path}")
            
            return self._build_response(
                f"‚úÖ Contexto de dados limpo: {file_path}",
                metadata={"cleared_data": file_path}
            )
        else:
            return self._build_response(
                "‚ÑπÔ∏è Nenhum contexto de dados para limpar",
                metadata={"no_data_context": True}
            )
    
    def get_available_agents(self) -> Dict[str, Any]:
        """Retorna informa√ß√µes sobre agentes dispon√≠veis."""
        agents_info = {}
        
        for name, agent in self.agents.items():
            agents_info[name] = {
                "name": agent.name,
                "description": agent.description,
                "class": agent.__class__.__name__
            }
        
        response = "ü§ñ **Agentes Dispon√≠veis**\n\n"
        for name, info in agents_info.items():
            response += f"‚Ä¢ **{name.upper()}**: {info['description']}\n"
        
        return self._build_response(response, metadata={"agents": agents_info})